#!/usr/bin/env bash
# @file software/official/flood/flood.sh
# @version 1.1.15
# @project MediaEase
# @description flood handler
# @author Thomas Chauveau (tomcdj71)
# @author_contact thomas.chauveau.pro@gmail.com
# @license BSD-3 Clause (Included in LICENSE)
# @copyright Copyright (C) 2025, MediaEase

# @function zen::software::flood::add
# @description Adds a Flood for a user, including downloading, configuring, and starting the service.
# @global software_config_file Path to the software's configuration file.
# @global user An associative array containing user-specific information.
# @note Disables SC2154 because the variable is defined in the main script.
# shellcheck disable=SC2154
zen::software::flood::add() {
    # grab the source code
    zen::dependency::external::install "$app_name"
    zen::git::clone "${config[github]}" "/opt/${user[username]}/$app_name"
    cd "/opt/${user[username]}/$app_name" || mflibs::status::error "$(zen::i18n::translate "errors.filesystem.change_directory" "/opt/${user[username]}/$app_name")"
    mflibs::log "su -c \"cd /opt/${user[username]}/$app_name; npm install --force && npm run build\" \"${user[username]}\""
    zen::software::flood::configure
    zen::software::backup::create "$app_name" "${config[config_file]}"
}

# shellcheck disable=SC2034
zen::software::flood::configure() {
    declare -g url_base
    local secret
    url_base="/${user[username]}/$app_name"
    mflibs::shell::text::white "$(zen::i18n::translate "messages.software.configure" "$app_name")"
    zen::software::autogen
    secret=$(openssl rand -hex 32)
    mkdir -p "/home/${user[username]}/.config/$app_name"
    zen::permission::private "/home/${user[username]}/.config/$app_name" "${user[username]}" "${user[username]}"
    cat >"/home/${user[username]}/.config/$app_name/env" <<EOF
FLOOD_OPTION_auth=default
FLOOD_OPTION_allowedPath=/home/${user[username]}
FLOOD_OPTION_baseuri=$url_base
FLOOD_OPTION_port=${default_port}
FLOOD_OPTION_secret=$secret
FLOOD_OPTION_rtsocket=/var/run/${user[username]}/.rtorrent.sock
EOF
    zen::service::generate "$app_name" "${config[config_file]}" "true"
    zen::proxy::generate "$app_name" "${default_port}" "${config[config_file]}"
    local beforeDirectives=("import ../fragments/basic_auth.${user[username]}.conf" "@stripPrefix path_regexp strip ^/${user[username]}/$app_name/(.*)$" "rewrite @stripPrefix /{http.regexp.strip.1}")
    for directive in "${beforeDirectives[@]}"; do
        zen::proxy::add_directive "$app_name" "${user[username]}" "$directive" "before"
    done
    local inDirectives=("header_up Host {upstream_hostport}" "header_up X-Forwarded-Prefix /${user[username]}/$app_name")
    for directive in "${inDirectives[@]}"; do
        zen::proxy::add_directive "$app_name" "${user[username]}" "$directive" "in"
    done
    mflibs::log "/usr/bin/caddy reload -c /etc/caddy/Caddyfile >/dev/null 2>&1"
    mflibs::shell::text::green "$(zen::i18n::translate "success.software.configure" "$app_name")"
}

# @function zen::software::flood::update
# @description Updates Flood for a user, including stopping the service, downloading the latest release, and restarting.
# @global user An associative array containing user-specific information.
# @global software_config_file Path to the software's configuration file.
zen::software::flood::update() {
    local service_name
    is_multi=$(zen::software::get_config_key_value "$software_config_file" '.arguments.multi_user')
    [ "$is_multi" == "true" ] && service_name="$app_name@${user[username]}.service" || service_name="$app_name.service"
    zen::service::manage "stop" "$service_name"
    zen::git::clone "${config[github]}" "/opt/${user[username]}/$app_name"
    cd "/opt/${user[username]}/$app_name" || mflibs::status::error "$(zen::i18n::translate "errors.filesystem.change_directory" "/opt/${user[username]}/$app_name")"
    mflibs::log "su -c \"cd /opt/${user[username]}/$app_name; npm install --force && npm run build\" \"${user[username]}\""
    zen::service::manage "start" "$service_name"
}

# @function zen::software::flood::remove
# @description Removes Flood for a user, including disabling and deleting the service and cleaning up files.
# @global user An associative array containing user-specific information.
zen::software::flood::remove() {
    local service_name
    is_multi=$(zen::software::get_config_key_value "$software_config_file" '.arguments.multi_user')
    [ "$is_multi" == "true" ] && service_name="$app_name@${user[username]}.service" || service_name="$app_name.service"

    zen::service::manage "disable" "$service_name"
    rm -f "$service_file"
    zen::proxy::remove "$app_name" "${user[username]}"
    rm -rf /opt/"${user[username]}"/"$app_name"
    rm -rf /home/"${user[username]}"/.config/"$app_name"
    rm -rf /home/"${user[username]}"/tmp/"$app_name"
}

# @function zen::software::flood::backup
# @description Creates a backup for Flood settings for a user.
# @note This function is currently a placeholder and needs implementation.
zen::software::flood::backup() {
    local username="$1"
    local app_name="$2"
}

# @function zen::software::flood::reset
# @description Resets Flood settings for a user.
# @note This function is currently a placeholder and needs implementation.
zen::software::flood::reset() {
    local username="$1"
    local app_name="$2"
}

# @function zen::software::flood::reinstall
# @description Reinstalls Flood for a user.
# @note This function is currently a placeholder and needs implementation.
zen::software::flood::reinstall() {
    local username="$1"
    local app_name="$2"
}
